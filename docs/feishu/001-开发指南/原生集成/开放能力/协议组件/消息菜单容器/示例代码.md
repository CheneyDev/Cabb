---
title: "示例代码"
source_url: https://open.feishu.cn/document/native-integration/open-capability/protocol-components/message-menu-container/sample-code
last_remote_update: 2024-11-27
last_remote_update_timestamp: 1732712059000
---
最后更新于 2024-11-27

# 示例代码

## iOS
下面的代码提供了一个示例场景，可以结合消息转发的能力组件，对聊天中的图片，文件等消息进行下载操作。
定义 `Menus` 和 `Menus2` 两个消息菜单实现

```javascript 
// LKMenusExternalIMP.swift
import Foundation
import UIKit
import LKMenusExternal
import LKMessageExternal
// 代码中定义了Menu1, icon为系统的邮箱图标，名字为转发邮箱
@available(iOS 13.0, *)
public class Menus: NSObject, UIViewController, KAMenusProtocol {
    var icon: UIImage = UIImage(systemName: "mail") ?? UIImage()

var label: String = "转发邮箱"

func canInitialize(_ actionContext: LKMenusExternal.ActionContext) -> Bool {
        return true
    }

// 点击按钮后的回调，在该函数下执行逻辑
    func onClick(_ actionContext: LKMenusExternal.ActionContext) {
        let message = actionContext.actionMessages.map { message in
            KAMessage.transform(message: message)
        }
        // 获取选择Message的信息
        KAMessageExternal.shared.getResources(messages: message) { infos in
            if infos.isEmpty {
                DispatchQueue.main.async {
                    self.showToast(message: "不支持的message info下载类型!")
                }
                return
            } else {
                DispatchQueue.main.async {
                    self.showToast(message: "可下载的类型，正在调取下载接口下载消息内文件到SDK路径中，请稍后......")
                    }
            }
            infos.forEach { info in
                KAMessageExternal.shared.downloadResource(messageInfo: info) { path in
                    DispatchQueue.main.async {
                        self.showToast(message: "下载成功, path: (path)")
                        }
                } onError: { error in
                    DispatchQueue.main.async {
                        self.showToast(message: "下载失败! error: (error)")
                    }
                }
            }
        } onError: { _ in
        }
    }

func showToast(message: String) {
        guard let window = UIApplication.shared.keyWindow else {
            return
        }
        // 创建提示视图
        let toastView = UIView(frame: CGRect(x: 0, y: 0, width: 400, height: 100))
        toastView.backgroundColor = UIColor.black.withAlphaComponent(0.7)
        toastView.center = window.center
        toastView.layer.cornerRadius = 10
        // 创建提示标签
        let toastLabel = UILabel(frame: toastView.bounds)
        toastLabel.text = message
        toastLabel.textColor = UIColor.white
        toastLabel.textAlignment = .center
        toastLabel.numberOfLines = 0
        toastLabel.font = UIFont.systemFont(ofSize: 16)
        // 将标签添加到提示视图
        toastView.addSubview(toastLabel)
        // 将提示视图添加到主窗口
        window.addSubview(toastView)
        // 延迟一定时间后移除提示视图
        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
            toastView.removeFromSuperview()
        }
    }
}
// 另一个消息菜单
public class Menus2: NSObject, KAMenusProtocol {
    var icon: UIImage = UIImage()

var label: String = "ka测试2"

func canInitialize(_ actionContext: LKMenusExternal.ActionContext) -> Bool {
        return false
    }

func onClick(_ actionContext: LKMenusExternal.ActionContext) {
        print("点击了KA2按钮")
    }
}
class EmptyBody: KAMessageBodyProtocol {}
private extension KAMessage {
    static func transform(message: ActionMessage) -> KAMessage {
        var type = KAMessageType.others
        switch message.type {
        case .file: type = .file
        case .video: type = .video
        case .image: type = .image
        default: type = .others
        }
        return KAMessage(type: type, id: message.id, body: EmptyBody())
    }
}
```
在 Object-C(.m) 文件代码中注册自定义的实现，load 函数会在加载 class 时执行。

方式一：直接在 OC 代码中注册（以`Menus`为例）
```javascript 
@import LKKABridge; // 引入 KAAPI_REGISTER 宏
@import LKMenusExternal;
#import <LKMenusExternalIMP/LKMenusExternalIMP-Swift.h> // 引入自定义的实现 Menus
#import "ka_auto_generated.h" // 引入 getChannel() 方法
@interface MenusRegistry: NSObject
@end
@implementation MenusRegistry
+(void)load {
    [KAAPI_REGISTER registerWithMenu:^id<KAMenusProtocol> {
        return [[Menus alloc] init];
    } cache:YES];
}
@end

```
方式二：在 OC 中调用 swift 代码注册（以`Menus2`为例）
- .swift 文件
```javascript 
import LKKABridge
import LKMenusExternal
@objcMembers
public class MenusLoader: NSObject {
    // 注册方法
    @objc public class func swiftLoad(channel: ID) {
        let api = KAAPI(channel: channel)
        api.register(menu: Menus2.init, cache: true)
    }
}
```
- .m 文件
```javascript 
#import "ka_auto_generated.h" // 引入 getChannel() 方法
#import <LKMenusExternalIMP/LKMenusExternalIMP-Swift.h> // 引入 MenusLoader 所在的.swift文件
@interface MenusRegistry: NSObject
@end
@implementation MenusRegistry
+(void)load {
    NSString * channel = [NSString stringWithUTF8String:getChannel()];
    [MenusLoader swiftLoadWithChannel:channel];
}
@end
```
