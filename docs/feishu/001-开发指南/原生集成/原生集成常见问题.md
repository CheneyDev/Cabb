---
title: "原生集成常见问题"
source_url: https://open.feishu.cn/document/native-integration/native-integration-qa
last_remote_update: 2024-09-11
last_remote_update_timestamp: 1726039950000
---
最后更新于 2024-09-11

# 原生集成常见问题

## 场景开放
### 1. 飞书业务层场景代码能否开放？具体开放了哪些场景？

飞书业务层场景代码本身无法开放，但是飞书开放了协议接口供客户调用。具体 API 参见[协议组件](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/native-integration/open-scene-introduction/protocol-components/webcontainer/android)和[能力组件](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/native-integration/open-scene-introduction/capability-components/applink-capability/android-appli)。

### 2. Webview 容器是否支持更多事件的扩展？

目前暂不支持客户自主扩展事件增加接口。有更多开放需求时，可联系飞书技术顾问提需求到产研侧评估。

## 代码开发
### 3. 【Android】 含有资源文件的模块应当如何设置独特且合适的 resourcePrefix？

#### **原因**

- 模块中经常出现简单的容易重名的资源名称，如 `msg`, `success`, `acitivity_main`等。如果多个不同的库出现了同名且内容不同的资源，编译后的产物只会存在一个资源，而且该类资源冲突不会阻塞编译，排查运行时问题会非常麻烦。
如果设置了 `resourcePrefix`，Android Studio 会对模块内没有前缀的资源报错提示。该配置仅对 Android Studio 生效，请手动检查而不是依赖 Gradle 的编译。
> Specifies this project's resource prefix to Android Studio for editor features, such as Lint checks. **This property is useful only when using Android Studio.**

#### **操作**
- 在 Android Library 模块的 `build.gradle` 中的 `android {}` 中配置。配置完且完成 Gradle sync 后，应当发现 Android Studio 有对现存的与不满足配置的前缀的资源文件发出警告。
**注意事项**：Android Library 模块判断依据：`build.gradle`中有直接或者间接引入`com.android.library`插件。

```
     android {
     resourcePrefix "xxx"
         // 请使用与功能相关且独特的前缀。例如带上当前公司channel的缩写以避免和其他类似功能的库的配置的冲突。
     } 
```  

- 将模块内的资源文件重命名（建议使用 Android Studio 自带的 Refactor -> Rename 功能）。
**注意事项**：注意：Android Studio 没有自带批量重命名功能，请逐个替换。

- 确认反射创建资源的方式（例如 [Resources.getIdentifier](https://developer.android.com/reference/android/content/res/Resources?hl=en#getIdentifier(java.lang.String,%20java.lang.String,%20java.lang.String))(**String** name, **String** defType, **String** defPackage)）的参数是否正确。

### 4. 【Android】如何引入本地 aar？
#### **背景**
从 AGP 4 开始，像引入本地 jar 一样引入本地 aar 会被编译器警告。因为官方认为这种方式引入的 aar 中的类与 Android 资源可能不会被打包进入产出的 aar 中。[查看官方链接](https://android.googlesource.com/platform/tools/base/+/7f61ff6d9d80a22322c9281da755a788fe854923)
```
Direct local .aar file dependencies are not supported when building an AAR. 
The resulting AAR would be broken because the classes and Android resources from any local .aar 
file dependencies would not be packaged in the resulting AAR. Previous versions of the Android 
Gradle Plugin produce broken AARs in this case too (despite not throwing this error).
```

#### **引入方式**
假定需要使用的 aar 为 x.aar，需要使用 aar 的模块为 module A。
- 需要为 x.aar 单独创建一个模块，例如 module x_wrapper。该模块中，会进入最终产物的代码与资源文件仅包括以下内容：

```
    module x_wrapper:
    - build.gradle
    - x.aar （有且仅有一个aar文件，如果有多个需要使用的本地aar文件，请为每个本地aar文件创建一个模块）
   （未展示.gitignore这种非代码与资源文件）
其中 `build.gradle` 内容如下：

- 离线构建模式：
  ```
  configurations.maybeCreate("default")
  artifacts.add("default", file('XXX.aar'))
  // 不要照抄，替换成aar在这个模块的相对路径
  ```

- 在线模式本地构建版本 （即插件版本为 0.0.1-rc30 或以上版本）：
  ```
  apply plugin: "lark.component.publish.single-artifact"
  ```

- 在线模式老版本：
  ```
  configurations.maybeCreate("default")
  artifacts.add("default", file('XXX.aar'))
  // 不要照抄，替换成aar在这个模块的相对路径
  // 以上就已经完成了本地aar的引入
  // 下面的代码是为了飞书能够正确的识别并发布该模块
  apply from: new File(rootDir, "publish.gradle").absolutePath
  alchemyComponentConfig {
  componentModuleType = 2
      componentName = "XXX"
      localAarFileName = "XXX.aar"
  }
  // 不要照抄，替换成aar的文件名
  ```
- Module A 中以 Project 形式依赖 module x_wrapper。
    ```
    dependencies {
          implementation(project( ":x_wrapper" ))
    }
   **注意事项**：**注意** **：**
包装本地 aar 的模块中禁止包含任何代码和资源文件，包括库或 AndroidManifest。即使包含，也无法生效。

### 5. 【Android】kotlin 开发的应用能集成吗？

可以，java、kotlin 都支持。

### 6. 【Android】什么是注解？什么情况下需要使用注解？

- 一般每个API都有一个对应的注解annotation，在类定义上加这个注解。
- 注解与SPI手动注入功效一样。在线模式，如果不想走SPI手动注入实现，就用注解形式。
- 示例：在实现了INativeAppPluginFactory的类上边加 @NativeAppPluginFactory注解

![image.png](https://sf3-cn.feishucdn.com/obj/open-platform-opendoc/2b4aec3a256f10329035c55bc651e7de_WrFa2ywlBw.png?height=956&lazyload=true&width=1534)

### 7. 小程序的请求是否需要转发到客户端？如若不需要，加密如何处理？

- 小程序是客户自己独立研发，前端发送请求后直接到客户的服务端，不需要经过客户端额外处理。
- 小程序的加密可考虑通过扩展API去做报文加密后再请求，具体可行性可联系飞书技术顾问评估。

### 8. H5 调用扩展的 JsApi 是否需要进行 API 鉴权？

调用扩展 JsApi 时，在线H5是需要鉴权的，但是离线包可以免鉴权。

### 9. 如何使用 APPLINK 打开原生集成应用？

以下链接为打开原生应用的Applink，请替换 <app_id> 为要跳转的原生应用appId：

https://applink.feishu.cn/client/native_app/open?appId=<app_id>

### 10.【Android】如何使用 Glide 加载 Gif ？

- Glide 不支持直接使用资源id来加载 dynamic-feature 中的 gif 资源，需要生成相应的 Uri;
- 使用 `Glide.with(context).asGif().load(R.drawable).into(view)` 会报错 `java.io.FileNotFoundException: No package foundfor authority: android.resource://`
- 参考资料：
    - [Glide cannot load gif resources located in dynamic feature module.](https://github.com/bumptech/glide/issues/4777)
    - [Building a URI for a resource](https://developer.android.com/guide/playcore/feature-delivery#resource-uri)
- 修复方式：

```javascript 
 Uri uri = Uri.Builder()
                .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
                .authority(context.getPackageName()) // Look up the resources in the application with its splits loaded
                .appendPath(resources.getResourceTypeName(resId))
                .appendPath(String.format("%s:%s",
                  resources.getResourcePackageName(resId), // Look up the dynamic resource in the split namespace.
                  resources.getResourceEntryName(resId)
                  ))
                .build();

// in Activity
Glide.with(this)
    .asGif()
    .load(uri)
    .into(image)
``` 

## 版本交付升级

### 11. 原生集成后的客户端发布流程机制是什么？如何升级更新？

- 支持根据客户端版本，按照组织架构、群群、人等维度灰度发布，引导用户升级更新。
- 飞书提供原生集成版本号，支持按照集成的版本号去做灰度发布，引导用户升级更新。

### 12. 是否支持热修复和版本回退？

saas、数据私有化、私有化部署客户端都不支持热修复和版本回退。

### 13. 原生集成的版本号如何管理？

原生集成的飞书展示的版本信息包含外部注入内容的版本信息，宿主应用未改动不需要升级飞书版本号，外部通过更新 **Alchemy** **version** 可升级提醒和完成升级动作，从而解决 KA 之间感知版本变化的问题。具体细节见文档：[开放平台原生集成版本管理](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/native-integration/specification-description/version-management)

### 14. 同时集成多个SDK应如何打包？

目前仅支持串行打包，并行打包规划中，暂不支持。

### 15. 集成冲突如何解决？

- 和飞书冲突，以飞书为准。
- 集成方之间冲突，以集成时间顺序为准，后者解决，兼容前者。

### 16. 多个 SDK 是否需要建立同一个代码仓库？

- 在线模式，不需要代码在一个仓库，正常推组件。后推的组件若与先推的组件冲突，后者解冲突。
- 离线模式，只要在私有化环境代码一起编译就行，一个仓库、多个仓库都可以。
